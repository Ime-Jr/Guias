{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"In\u00edcio","text":"<p>  IME Jr.  </p> <p>O reposit\u00f3rio de guias da J\u00fanior tem como objetivo centralizar informa\u00e7\u00f5es e guias para os membros da empresa. Desejamos que este reposit\u00f3rio se torne uma refer\u00eancia para todos, servindo como um guia essencial para o desenvolvimento de suas atividades. Os guias podem abranger tanto aspectos t\u00e9cnicos, relacionados \u00e0s ferramentas e workflows utilizados na empresa, quanto t\u00f3picos de interesse dos membros para aprendizado e compartilhamento. Com essa vis\u00e3o, o reposit\u00f3rio est\u00e1 aberto a contribui\u00e7\u00f5es de todos os membros, e esperamos que todos colaborem com guias e informa\u00e7\u00f5es relevantes. </p>"},{"location":"#organizacao","title":"Organiza\u00e7\u00e3o \ud83e\uddf9\ud83d\udca8","text":"<p>A parte escrita do seu guia deve ser feita em Markdown, um formato de escrita simples e f\u00e1cil de aprender. Al\u00e9m disso, utilizamos o MkDocs para a organiza\u00e7\u00e3o e visualiza\u00e7\u00e3o dos guias como um site. O site \u00e9 gerado a partir dos arquivos Markdown presentes no reposit\u00f3rio e \u00e9 atualizado automaticamente a cada push na branch main. Para contribuir com o reposit\u00f3rio, basta criar um arquivo Markdown com o conte\u00fado do seu guia e submet\u00ea-lo via pull request.</p> <p>Ao adicionar uma nova contribui\u00e7\u00e3o, voc\u00ea deve verificar em qual categoria o guia se encaixa e adicionar o arquivo na pasta correspondente. Caso a categoria n\u00e3o exista, voc\u00ea pode criar uma nova pasta e adicionar o arquivo l\u00e1. Se for o caso de uma nova categoria, voc\u00ea tamb\u00e9m deve adicion\u00e1-la ao arquivo mkdocs.yml para que o guia seja exibido no site e na barra de navega\u00e7\u00e3o.</p> <p>As categorias existentes s\u00e3o:</p> <ul> <li>Matem\u00e1tica e Estat\u00edstica</li> <li>Ci\u00eancia de Dados</li> <li>Desenvolvimento Web</li> <li>Automa\u00e7\u00e3o</li> <li>Design</li> <li>Outros</li> </ul> <p>Por exemplo, um guia sobre \"Como criar uma API REST com Flask\" poderia ser adicionado na pasta Desenvolvimento Web, e um guia sobre \"Como fazer um gr\u00e1fico de barras no Python\" poderia ser adicionado na pasta Ci\u00eancia de Dados. Caso seu guia se encaixe em mais de uma categoria, escolha a que mais se adequa e adicione tags no arquivo Markdown para facilitar a busca.</p> <p>Se o seu guia incluir c\u00f3digo-fonte ou qualquer outro tipo de arquivo que n\u00e3o seja um arquivo Markdown, voc\u00ea pode adicionar esses arquivos na pasta <code>src/&lt;categoria&gt;/&lt;nome-do-guia&gt;</code>. Por exemplo, se o guia \"Como criar uma API REST com Flask\" incluir um arquivo app.py, voc\u00ea pode adicion\u00e1-lo na pasta <code>src/desenvolvimento-web/como-criar-uma-api-rest-com-flask/app.py</code>.</p> <p>Se sentir a necessidade de modificar a estrutura do reposit\u00f3rio, sinta-se livre para abrir uma issue e discutir a mudan\u00e7a com os demais membros.</p>"},{"location":"#como-contribuir","title":"Como contribuir \ud83e\udd1d","text":"<p>Para contribuir neste projeto, basta criar uma pull request e aguardar que um administrador da organiza\u00e7\u00e3o avalie e forne\u00e7a um feedback. Se a sua contribui\u00e7\u00e3o incluir algum material novo, \u00e9 importante manter a organiza\u00e7\u00e3o atual do reposit\u00f3rio devidamente documentada (afinal, o objetivo \u00e9 ajudar os outros!). Sinta-se \u00e0 vontade para compartilhar o que voc\u00ea achar necess\u00e1rio; todo conhecimento \u00e9 bem-vindo!</p> <p>Abaixo, temos um guia r\u00e1pido de como contribuir com o reposit\u00f3rio:</p> <pre><code>1. Clone o reposit\u00f3rio\n2. Crie uma nova branch  \n3. Adicione o guia na pasta correspondente\n4. Adicione tags ao guia, se necess\u00e1rio\n5. Adicione arquivos extras na pasta `src` se necess\u00e1rio\n6. Adicione seu nome e contato no arquivo `AUTHORS.md` na pasta do guia\n7. Fa\u00e7a um commit e push das altera\u00e7\u00f5es\n8. Crie uma pull request\n</code></pre> <p>Assim que a pull request for aprovada, o guia ser\u00e1 adicionado ao site e estar\u00e1 dispon\u00edvel para todos os membros da empresa.</p> <p>Se um conte\u00fado compartilhado \u00e9 oferecido por terceiro, n\u00e3o se esque\u00e7a de dar os devidos cr\u00e9ditos. Se deseja ser creditado por sua contribui\u00e7\u00e3o, adicione um arquivo <code>AUTHORS.md</code> na pasta do guia com seu nome e contato.</p>"},{"location":"#como-rodar-o-site-localmente","title":"Como rodar o site localmente \ud83d\udda5\ufe0f","text":"<p>Como dito anteriormente, o site \u00e9 gerado a partir dos arquivos Markdown presentes no reposit\u00f3rio. Para visualizar o site localmente, voc\u00ea precisar\u00e1 instalar o MkDocs e rodar o servidor localmente. Para isso, siga os passos abaixo:</p> <ol> <li>Instale as depend\u00eancias do MkDocs:     <pre><code>pip install pyproject.toml\n</code></pre></li> <li>Rode o servidor local:     <pre><code>mkdocs serve\n</code></pre></li> <li>Acesse o site em <code>http://localhost:8000</code></li> </ol>"},{"location":"#duvidas-e-sugestoes","title":"D\u00favidas e sugest\u00f5es \ud83e\udd14","text":"<p>Caso tenha alguma d\u00favida ou sugest\u00e3o, sinta-se \u00e0 vontade para usar a aba de discuss\u00f5es do reposit\u00f3rio. Estamos sempre abertos a sugest\u00f5es e feedbacks para melhorar o reposit\u00f3rio e torn\u00e1-lo mais \u00fatil para todos os membros da empresa.</p>"},{"location":"matematica-estatistica/inicio/","title":"In\u00edcio","text":"<p>A matem\u00e1tica e a estat\u00edstica s\u00e3o ferramentas fundamentais para a an\u00e1lise de dados e a tomada de decis\u00f5es. Nesta se\u00e7\u00e3o, voc\u00ea encontrar\u00e1 guias e tutoriais sobre conceitos e t\u00e9cnicas matem\u00e1ticas e estat\u00edsticas que s\u00e3o comumente utilizados em projetos de desenvolvimento de software.</p>"},{"location":"matematica-estatistica/inicio/#topicos","title":"T\u00f3picos","text":"<ul> <li>Resolvendo o Campo Minado com Python: Aprenda a resolver um jogo de Campo Minado utilizando Python:  <p>Neste guia, voc\u00ea aprender\u00e1 a resolver um jogo de Campo Minado utilizando Python. No guia, \u00e9 apresentado uma implementa\u00e7\u00e3o do jogo e \u00e9 discutido uma s\u00e9rie de m\u00e9todos para resolver o jogo de forma eficiente. Alguns dos m\u00e9todos discutidos incluem: Teoria da informa\u00e7\u00e3o, busca em largura, redes neurais e programa\u00e7\u00e3o linear.</p> </li> </ul>"},{"location":"matematica-estatistica/resolvendo-o-campo-minado-com-python/","title":"Resolvendo o Campo Minado com Python","text":"<p>Neste guia, voc\u00ea aprender\u00e1 a implementar um jogo de Campo Minado utilizando Python e a resolver o jogo de forma eficiente. Meu objetivo \u00e9 apresentar como podemos utilizar diferentes modelagens matem\u00e1ticas e algoritmos para resolver o jogo de forma eficiente. Cada um dos m\u00e9todos apresentados tem suas vantagens e desvantagens, e exigem um certo nivel de conhecimento x e y, mas nada proibitivo. Este guia \u00e9 estruturado da seguinte forma:</p> <ul> <li> <p>Parte 1: Implementa\u00e7\u00e3o do jogo de Campo Minado</p> <p>Nesta parte, apresento uma implementa\u00e7\u00e3o do jogo de Campo Minado utilizando Python. A implementa\u00e7\u00e3o \u00e9 feita de forma simples e eficiente, e \u00e9 utilizada como base para os m\u00e9todos de resolu\u00e7\u00e3o apresentados nas pr\u00f3ximas partes.</p> </li> <li> <p>Parte 2: Resolvendo o Campo Minado com Teoria da Informa\u00e7\u00e3o</p> <p>Nesta parte, apresento um m\u00e9todo para resolver o jogo de Campo Minado utilizando Teoria da Informa\u00e7\u00e3o. A Teoria da Informa\u00e7\u00e3o \u00e9 uma \u00e1rea da matem\u00e1tica que estuda a quantifica\u00e7\u00e3o da informa\u00e7\u00e3o e \u00e9 utilizada em diversas \u00e1reas, como ci\u00eancia da computa\u00e7\u00e3o, estat\u00edstica e f\u00edsica.</p> </li> <li> <p>Parte 3: Resolvendo o Campo Minado com Busca em Largura</p> <p>Nesta parte, apresento um m\u00e9todo para resolver o jogo de Campo Minado utilizando Busca em Largura. A Busca em Largura \u00e9 um algoritmo de busca em grafos que \u00e9 utilizado para encontrar o caminho mais curto entre dois v\u00e9rtices de um grafo.</p> </li> <li> <p>Parte 4: Resolvendo o Campo Minado com Redes Neurais</p> <p>Nesta parte, apresento um m\u00e9todo para resolver o jogo de Campo Minado utilizando Redes Neurais. As Redes Neurais s\u00e3o modelos computacionais inspirados no sistema nervoso dos animais e s\u00e3o utilizadas em diversas \u00e1reas, como reconhecimento de padr\u00f5es, processamento de linguagem natural e vis\u00e3o computacional. Al\u00e9m disso, irei mostrar a rela\u00e7\u00e3o entre as Redes Neurais e outros m\u00e9todos de resolu\u00e7\u00e3o apresentados neste guia.</p> </li> </ul>"},{"location":"matematica-estatistica/resolvendo-o-campo-minado-com-python/#parte-1-implementacao-do-jogo-de-campo-minado","title":"Parte 1: Implementa\u00e7\u00e3o do jogo de Campo Minado","text":"<p>Antes de come\u00e7armos, vamos entender como funciona o jogo de Campo Minado. O jogo \u00e9 composto por uma matriz de c\u00e9lulas, onde cada c\u00e9lula pode estar vazia ou conter uma mina. O objetivo do jogo \u00e9 descobrir todas as c\u00e9lulas vazias sem detonar uma mina. Para isso, o jogador pode clicar em uma c\u00e9lula para revelar seu conte\u00fado. Se a c\u00e9lula clicada contiver uma mina, o jogo acaba e o jogador perde. Se a c\u00e9lula clicada estiver vazia, o jogo continua e o jogador pode clicar em outras c\u00e9lulas at\u00e9 que todas as c\u00e9lulas vazias sejam reveladas.</p> <p>Ao clicar em uma c\u00e9lula vazia, existem duas possibilidades: ou h\u00e1 minas adjacentes \u00e0 c\u00e9lula, ou n\u00e3o h\u00e1. Se houver minas adjacentes \u00e0 c\u00e9lula, a c\u00e9lula exibir\u00e1 o n\u00famero de minas adjacentes. Se n\u00e3o houver minas adjacentes, a c\u00e9lula ser\u00e1 revelada e as c\u00e9lulas adjacentes tamb\u00e9m ser\u00e3o reveladas automaticamente, de forma recursiva. Em outras palavras, quando n\u00e3o h\u00e1 minas adjacentes, o jogo revela todas as c\u00e9lulas adjacentes at\u00e9 que a fronteira de minas seja atingida.</p> Figura 1: Exemplo de jogo de Campo Minado 3x3 , ap\u00f3s clicar na c\u00e9lula (2, 2) Figura 2: Exemplo de Campo Minado ap\u00f3s clicar na c\u00e9lula (2,2)  Astrisco(*) representa minas <p>Nas imagens acima, a figura 1 mostra um exemplo de jogo de Campo Minado 3x3, onde o jogador clicou na c\u00e9lula (2, 2). Neste caso, foram reveladas duas bombas adjacentes \u00e0 c\u00e9lula clicada. A figura 2 mostra o mesmo jogo ap\u00f3s clicar na mesma c\u00e9lula, mas desta vez, a c\u00e9lula clicada n\u00e3o possui bombas adjacentes. Neste caso, todas as c\u00e9lulas adjacentes \u00e0 c\u00e9lula clicada foram reveladas automaticamente.</p> <p>Nota</p> <p>Neste guia, iremos sempre considerar que o \u00edndice da primeira linha e coluna \u00e9 0. Ou seja, a c\u00e9lula (0, 0) \u00e9 a c\u00e9lula no canto superior esquerdo da matriz.</p> <p>Agora que entendemos as regras do jogo, vamos implementar o jogo de Campo Minado em Python. A nossa estrat\u00e9gia ser\u00e1 utilizar POO para criar uma classe que representar\u00e1 o jogo e seus m\u00e9todos.</p> <pre><code>from random import sample\n\nclass CampoMinado:\n    __BOMB_INDICATOR = \"*\"\n    __UNKNOWN_CELL_INDICATOR = \"?\"\n\n    def __init__(self, rows, cols, bombs):\n        self.nrows = rows\n        self.ncols = cols\n        self.nbombs = bombs\n        self.board = [self.__UNKNOWN_CELL_INDICATOR for _ in range(self.ncols) for _ in range(self.nrows)]\n        self.__secret_board = self.generate_secret_board()\n\n\n    def generate_secret_board(self):\n        \"\"\"\n        Gera um tabuleiro secreto com as bombas em posi\u00e7\u00f5es aleat\u00f3rias\n        \"\"\"\n        # Inicializa o tabuleiro com todas as c\u00e9lulas vazias\n        board = [0 for _ in range(self.nrows) for __ in range(self.ncols)]\n\n        # Cria uma amostra aleat\u00f3ria de \u00edndices e insere as bombas no tabuleiro\n        bombs_index = sample(range(self.nrows*self.ncols), self.nbombs)\n        for bi in bombs_index:\n            board[bi] = self.__BOMB_INDICATOR\n        return board\n</code></pre> <p>O c\u00f3digo acima implementa a classe CampoMinado, que representa o jogo de Campo Minado. A classe possui um construtor que inicializa o tabuleiro do jogo com c\u00e9lulas desconhecidas e gera um tabuleiro secreto com as bombas. O m\u00e9todo generate_secret_board() \u00e9 respons\u00e1vel por gerar o tabuleiro secreto com as bombas de forma aleat\u00f3ria. N\u00f3s tamb\u00e9m definimos alguns atributos privados, como __BOMB_INDICATOR e __UNKNOWN_CELL_INDICATOR, que s\u00e3o utilizados para representar as bombas e as c\u00e9lulas desconhecidas no tabuleiro, respectivamente. Vamos testar a nossa implementa\u00e7\u00e3o do jogo de Campo Minado:</p> <pre><code>game = CampoMinado(3, 3, 2)\nprint(game.board)\n# Vamos tamb\u00e9m imprimir o tabuleiro secreto apenas para ver as bombas\nprint(game._CampoMinado__secret_board)\n</code></pre> <p>O c\u00f3digo acima cria um jogo de Campo Minado 3x3 com 2 bombas e imprime o tabuleiro do jogo e o tabuleiro secreto com as bombas. A sa\u00edda do c\u00f3digo ser\u00e1 algo como:</p> <pre><code>['?', '?', '?', '?', '?', '?', '?', '?', '?']\n[0, 0, 0, 0, 0, 0, '*', 0, '*']\n</code></pre> <p>Nota</p> <p>Aqui, estamos tratando o tabuleiro como uma lista unidimensional. Uma outra alternativa seria representar o tabuleiro como uma lista de listas, onde cada lista interna representa uma linha do tabuleiro. A escolha entre as duas representa\u00e7\u00f5es n\u00e3o ir\u00e1 afetar a implementa\u00e7\u00e3o dos m\u00e9todos de resolu\u00e7\u00e3o do jogo. A minha escolha por representar o tabuleiro como uma lista unidimensional \u00e9 que o \u00edndice de uma c\u00e9lula \u00e9 calculado como <code>i = row * ncols + col</code>, o que facilita a convers\u00e3o entre as coordenadas (row, col) e o \u00edndice da c\u00e9lula na lista.</p> <p>Nossos testes nos revelam duas coisas que precisaremos nos preocupar na pr\u00f3xima parte: 1. Uma boa visualiza\u00e7\u00e3o do tabuleiro e 2. A implementa\u00e7\u00e3o de um m\u00e9todo para revelar as c\u00e9lulas do tabuleiro. Como veremos adiante, o m\u00e9todo para revelar as c\u00e9lulas do tabuleiro \u00e9 um tanto complexo, ent\u00e3o vamos nos concentrar em implementar um m\u00e9todo para visualizar o tabuleiro, o que nos permitir\u00e1 validar a nossa implementa\u00e7\u00e3o do jogo.</p> <pre><code># ... outros imports\nimport colorama\n\nclass CampoMinado:\n    # ... Outros atributos privados\n    DISPLAY_CELL_CHARS = 6 # Quantidade de caracteres para exibir cada c\u00e9lula\n\n    # ... outros m\u00e9todos\n\n    def colorize(self, color_code, content):\n        # O dict COLORS_MAP mapeia os c\u00f3digos de cores aos c\u00f3digos ANSI.\n        # Voc\u00ea pode adicionar mais cores ao dict, se desejar. As chaves s\u00e3o poss\u00edveis \n        # valores na c\u00e9lula e os valores s\u00e3o os c\u00f3digos ANSI correspondentes.\n        # Desta forma, verde ser\u00e1 usado para c\u00e9lulas vazias, ciano para c\u00e9lulas com 1 mina adjacente, etc.\n        color_code = str(color_code)\n        COLORS_MAP = {\n            \"0\": colorama.Fore.GREEN,\n            \"1\": colorama.Fore.CYAN,\n            \"2\": colorama.Fore.BLUE,\n            \"3\": colorama.Fore.RED,\n            \"4\": colorama.Fore.RED,\n            \"5\": colorama.Fore.MAGENTA,\n            \"6\": colorama.Fore.MAGENTA,\n            self.__BOMB_INDICATOR: colorama.Fore.RED,\n            self.__UNKNOWN_CELL_INDICATOR: colorama.Fore.WHITE,\n            \"C\": colorama.Fore.WHITE # Usado para as colunas de coordenadas\n        }\n\n        return f\"{COLORS_MAP[color_code]}{content}{colorama.Fore.RESET}\"\n\n    def show_board(self, target_board: list):\n        \"\"\"\n        Mostra o tabuleiro na tela\n        \"\"\"\n        board_str = f\"{colorama.Back.BLACK}\" # Adiciona um fundo preto ao tabuleiro\n        # Calcula a largura da linha do tabuleiro. Adicionamos 1 ao n\u00famero de colunas para incluir as coordenadas,\n        # um ao n\u00famero de caracteres por c\u00e9lula para incluir a '|' entre as c\u00e9lulas e um ao final para incluir o \u00faltimo '|'\n        row_width = (self.ncols+1) * (self.DISPLAY_CELL_CHARS + 1) + 1\n\n        # Agora, vamos gerar um pequeno cabe\u00e7alho com as coordenadas das colunas\n        header = \"\"\n        header += f\" Campo Minado {self.nrows}x{self.ncols} \".center(row_width, \"-\") + \"\\n\"\n        header += \"-\" * row_width + \"\\n\" # Adiciona uma linha horizontal para separar o cabe\u00e7alho do tabuleiro\n        # Gera os \u00edndices das colunas e os formata para exibi\u00e7\u00e3o, aplicando a fun\u00e7\u00e3o colorize e centralizando o texto\n        header_col_indexer = [self.colorize(content=str(v).center(self.DISPLAY_CELL_CHARS), color_code=\"C\") for v in range(self.ncols)]\n        # Veja que aqui adicionamos uma coluna adicional com '/' para separar as coordenadas das c\u00e9lulas e as c\u00e9lulas em si. \n        header += f\"|{'/'.center(self.DISPLAY_CELL_CHARS)}|\" + \"|\".join(c for c in header_col_indexer) + \"|\\n\" \n        header += \"-\"*row_width + \"\\n\"\n\n        # finalmente, vamos adicionar o cabe\u00e7alho ao tabuleiro\n        board_str += header\n\n        # Agora, vamos adicionar as linhas do tabuleiro\n        for ri in range(self.nrows):\n            start_index = self.cols * ri\n            end_index = self.ncols * (ri + 1)         \n            cells = [self.colorize(content=str(v).center(self.DISPLAY_CELL_CHARS), color_code=v) for v in target_board[start_index:end_index]]\n            # Vamos adicioar, de uma vez s\u00f3, a linha e sua respectiva coordenada na coluna\n            board_str += f\"|{self.colorize('C', str(ri).center(self.DISPLAY_CELL_CHARS))}|\" + \"|\".join(c for c in cells) + \"|\\n\"\n        board_str += f\"{colorama.Back.RESET}\"\n        print(board_str)\n\n    @property\n    def show(self):\n        return self.show_board(target_board=self.board)\n\n    @property\n    def show_answer(self):\n        self.show_board(target_board=self.__secret_board)\n</code></pre> <p>O c\u00f3digo acima implementa o m\u00e9todo show_board(), que \u00e9 respons\u00e1vel por exibir o tabuleiro do jogo na tela. O m\u00e9todo gera uma representa\u00e7\u00e3o visual do tabuleiro, com cores diferentes para as c\u00e9lulas vazias, as c\u00e9lulas com minas adjacentes e as bombas. O m\u00e9todo utiliza a biblioteca colorama para adicionar cores ao texto exibido no terminal. Al\u00e9m disso, o m\u00e9todo show_board() tamb\u00e9m cria um cabe\u00e7alho, uma linha e uma coluna de coordenadas para facilitar a visualiza\u00e7\u00e3o do tabuleiro. Al\u00e9m disso, criamos duas propriedades, show e show_answer, que exibem o tabuleiro do jogo e o tabuleiro secreto, respectivamente. Vamos testar a nossa implementa\u00e7\u00e3o do m\u00e9todo show_board():</p> <pre><code>game = CampoMinado(3, 3, 2)\ngame.show\ngame.show_answer\n</code></pre> <p>Voc\u00ea deve ver algo como:</p> <p><pre><code>------ Campo Minado 3x3 -----\n-----------------------------\n|  /   |  0   |  1   |  2   |\n-----------------------------\n|  0   |  ?   |  ?   |  ?   |\n|  1   |  ?   |  ?   |  ?   |\n|  2   |  ?   |  ?   |  ?   |\n-----------------------------\n</code></pre> E o tabuleiro secreto, onde no lugar de '?' voc\u00ea ver\u00e1 as bombas:</p> <pre><code>------ Campo Minado 3x3 -----\n-----------------------------\n|  /   |  0   |  1   |  2   |\n-----------------------------\n|  0   |  *   |  0   |  0   |\n|  1   |  *   |  0   |  0   |\n|  2   |  0   |  0   |  0   |\n-----------------------------\n</code></pre> <p>\u00d3timo! Estamos quase prontos para come\u00e7ar a implementar os m\u00e9todos de resolu\u00e7\u00e3o do jogo. Agora podemos nos concentrar em implementar um m\u00e9todo para revelar as c\u00e9lulas do tabuleiro. A estrat\u00e9gia que utilizarei ser\u00e1 o seguinte: Primeiro, criarei um m\u00e9todo que retorna o \u00edndice de todas as c\u00e9lulas v\u00e1lidas adjacentes a uma c\u00e9lula dada. Em seguida, criarei um m\u00e9todo que conta a quantidade de bombas adjacentes. Neste momento, iremos intercalar o uso de indices e coordenadas(linha, coluna), ent\u00e3o vamos criar um m\u00e9todo para converter entre os dois sistemas de refer\u00eancia.</p> <pre><code>class CampoMinado:\n    # ... Outros m\u00e9todos\n\n    def coord_to_index(self, row, col):\n        \"\"\"\n        Converte as coordenadas (linha, coluna) em um \u00edndice da lista unidimensional\n        \"\"\"\n        return row * self.ncols + col\n\n    def index_to_coord(self, index):\n        \"\"\"\n        Converte um \u00edndice da lista unidimensional em coordenadas (linha, coluna)\n        \"\"\"\n        return divmod(index, self.ncols) \n\n    def get_valid_adjacent_cells(self, row, col):\n        \"\"\"\n        Retorna os \u00edndices das c\u00e9lulas v\u00e1lidas adjacentes \u00e0 c\u00e9lula (row, col)\n        \"\"\"\n        cindex = self.coord_to_index(row, col)\n\n        adjacent_indexes = [\n            cindex-self.nrows-1, cindex-self.nrows, cindex-self.nrows+1,\n            cindex-1,            -1000             ,cindex+1,\n            cindex+self.nrows-1, cindex+self.nrows, cindex+self.nrows+1\n        ] \n\n        # a constante -1000 \u00e9 um valor simbolico para que os indices fiquem coerentes.\n        # Agora, deveremos remover os indices de celulas vizinhas seguindo o seguinte criterio:\n        # 1. Se o index for negativo (significa que nao existe linha 'acima', ou eh a constante simbolica)\n        # 2. Se o index for maior q o tabuleiro(neste caso, nao existe linha 'abaixo')\n        # 3. Se cindex % ncol = 1, deveremos remover os indices(do adjacent_indexes) 2, 5, e 8\n        # 4. se cindex % ncol = ncol, deveremos remover os indices(do adjacent_indexes) 0, 3 e 6\n        # obs: os passos 3 e 4 usam cindex(o valor de input). Ambos referem-se ao caso onde\n        # o indice de target est\u00e1 ou na coluna final, ou na coluna inicial. Logo nao existe \"esquerda\" ou \"direita\"\n\n        # Como os passos  3. e 4. removem valores do vetor de indice usando seus indices, vamos come\u00e7ar por eles \n        to_remove = []\n        if cindex % self.ncols == self.ncols - 1:\n            to_remove.extend([2, 5, 8])\n        elif cindex % self.ncols == 0:\n            to_remove.extend([0, 3, 6])\n\n        # Agora, vamos remover os indices que nao existem\n        # board_ index = indice da celula no tabuleiro; adj_index = indice no vetor de adjacent_indexes\n        adjacent_cells = [board_index for adj_index, board_index in enumerate(adjacent_indexes) if board_index &gt;= 0 and board_index &lt; self.nrows*self.ncolumns and adj_index not in to_remove]\n        return adjacent_cells\n\n    def count_adjacent_bombs(self, row, col):\n        \"\"\"\n        Conta o n\u00famero de bombas adjacentes \u00e0 c\u00e9lula (row, col)\n        \"\"\"\n        cindex = self.coord_to_index(row, col)\n\n        adjacent_cells = self.get_valid_adjacent_cells(row, col)\n        return sum(1 for adj_index in adjacent_cells if self.__secret_board[adj_index] == self.__BOMB_INDICATOR)\n\n    def recursive_count_adjacent_bombs(self, row, col):\n        \"\"\"\n        Conta o n\u00famero de bombas adjacentes \u00e0 c\u00e9lula (row, col) e \u00e0s c\u00e9lulas adjacentes a ela, de forma recursiva\n        \"\"\"\n        bombs_count = self.count_adjacent_bombs(row, col)\n        cindex = self.coord_to_index(row, col)\n        self.board[cindex] = bombs_count\n        if b_count &gt; 0:\n            return\n\n        adjacent_cells = self.get_valid_adjacent_cells(row, col)\n        for adj_index in adjacent_cells:\n            adj_row, adj_col = self.index_to_coord(adj_index)\n            if self.board[adj_index] == self.__UNKNOWN_CELL_INDICATOR:\n                self.recursive_count_adjacent_bombs(adj_row, adj_col)\n        return\n</code></pre> <p>Uuuufa! Muita coisa, n\u00e3o \u00e9? Vamos entender o que fizemos. Primeiro, criamos dois m\u00e9todos, coord_to_index() e index_to_coord(), que convertem entre coordenadas (linha, coluna) e \u00edndices da lista unidimensional. Em seguida, criamos o m\u00e9todo get_valid_adjacent_cells(), que retorna os \u00edndices das c\u00e9lulas v\u00e1lidas adjacentes a uma c\u00e9lula dada. O m\u00e9todo count_adjacent_bombs() conta o n\u00famero de bombas adjacentes a uma c\u00e9lula dada. Por fim, o m\u00e9todo recursive_count_adjacent_bombs() conta o n\u00famero de bombas adjacentes a uma c\u00e9lula dada e \u00e0s c\u00e9lulas adjacentes a ela, de forma recursiva. Este m\u00e9todo \u00e9 respons\u00e1vel por revelar as c\u00e9lulas do tabuleiro que n\u00e3o possuem bombas adjacentes. A Noticia boa \u00e9 que a nossa implementa\u00e7\u00e3o do metodo <code>reveal</code> \u00e9 bem simples, ent\u00e3o vamos implement\u00e1-lo e test\u00e1-lo.</p> <pre><code>class GameOverError(Exception):\n    pass \n\nclass CampoMinado:\n    # ... Outros m\u00e9todos\n\n    def reveal(self, row, col):\n        \"\"\"\n        Revela a c\u00e9lula (row, col) e as c\u00e9lulas adjacentes a ela\n        \"\"\"\n        cindex = self.coord_to_index(row, col)\n        if self.__secret_board[cindex] == self.__BOMB_INDICATOR:\n            raise GameOverError(\"Voc\u00ea clicou em uma bomba! Game Over!\")\n            return\n        self.recursive_count_adjacent_bombs(row, col)\n</code></pre> <p>O m\u00e9todo reveal() \u00e9 respons\u00e1vel por revelar a c\u00e9lula (row, col) e as c\u00e9lulas adjacentes a ela. Se a c\u00e9lula clicada contiver uma bomba, o m\u00e9todo lan\u00e7a uma exce\u00e7\u00e3o GameOverError. Vamos testar a nossa implementa\u00e7\u00e3o do m\u00e9todo reveal():</p> <pre><code>game = CampoMinado(5, 5, 3)\ngame.show\ngame.reveal(0, 1)\ngame.show\n</code></pre> <p>Voc\u00ea deve ver algo como:</p> <pre><code>------------- Campo Minado 5x5 ------------\n-------------------------------------------\n|  /   |  0   |  1   |  2   |  3   |  4   |\n-------------------------------------------\n|  0   |  0   |  0   |  1   |  ?   |  ?   |\n|  1   |  0   |  0   |  1   |  ?   |  ?   |\n|  2   |  1   |  1   |  2   |  ?   |  ?   |\n|  3   |  ?   |  ?   |  ?   |  ?   |  ?   |\n|  4   |  ?   |  1   |  ?   |  ?   |  ?   |\n-------------------------------------------\n</code></pre> <p>Para que voc\u00ea possa testar a implementa\u00e7\u00e3o do jogo com um pouco mais de calma, vamos criar um m\u00e9todo que permita ao jogador interagir com o jogo. Vamos implementar um m\u00e9todo play() que solicita ao jogador as coordenadas da c\u00e9lula a ser revelada e revela a c\u00e9lula. O m\u00e9todo play() deve continuar solicitando as coordenadas at\u00e9 que o jogador clique em uma bomba ou revele todas as c\u00e9lulas vazias. Vamos implementar o m\u00e9todo play() e test\u00e1-lo:</p> <pre><code>import os\n\nclass CampoMinado:\n    # ... Outros m\u00e9todos\n\n    def play(self):\n        \"\"\"\n        Permite ao jogador interagir com o jogo\n        \"\"\"\n        while True:\n            self.show\n            row = int(input(\"Digite a linha da c\u00e9lula a ser revelada: \"))\n            col = int(input(\"Digite a coluna da c\u00e9lula a ser revelada: \"))\n            try:\n                os.system('cls' if os.name == 'nt' else 'clear')\n                self.reveal(row, col)\n            except GameOverError as e:\n                print(e)\n                break\n            if self.board.count(self.__UNKNOWN_CELL_INDICATOR) == self.nbombs:\n                print(\"Parab\u00e9ns! Voc\u00ea revelou todas as c\u00e9lulas vazias!\")\n                break\n</code></pre> <p>O m\u00e9todo play() exibe o tabuleiro do jogo e solicita ao jogador as coordenadas da c\u00e9lula a ser revelada. O m\u00e9todo continua solicitando as coordenadas at\u00e9 que o jogador clique em uma bomba ou revele todas as c\u00e9lulas vazias. </p> Implementa\u00e7\u00e3o do jogo de Campo Minado <pre><code>from random import sample\nfrom typing import Literal\nimport colorama\nimport os\n\nclass GameOverError(Exception):\n    pass \n\nclass CampoMinado:\n    __BOMB_INDICATOR = \"*\"\n    __UNKNOWN_CELL_INDICATOR = \"?\"\n    DISPLAY_CELL_CHARS = 6 # Quantidade de caracteres para exibir cada c\u00e9lula\n\n\n    def __init__(self, rows, cols, bombs):\n        self.nrows = rows\n        self.ncols = cols\n        self.nbombs = bombs\n        self.board = [self.__UNKNOWN_CELL_INDICATOR for _ in range(self.ncols) for _ in range(self.nrows)]\n        self.__secret_board = self.generate_secret_board()\n\n\n    def generate_secret_board(self):\n        \"\"\"\n        Gera um tabuleiro secreto com as bombas em posi\u00e7\u00f5es aleat\u00f3rias\n        \"\"\"\n        # Inicializa o tabuleiro com todas as c\u00e9lulas vazias\n        board = [0 for _ in range(self.nrows) for __ in range(self.ncols)]\n\n        # Cria uma amostra aleat\u00f3ria de \u00edndices e insere as bombas no tabuleiro\n        bombs_index = sample(range(self.nrows*self.ncols), self.nbombs)\n        for bi in bombs_index:\n            board[bi] = self.__BOMB_INDICATOR\n        return board\n\n    def colorize(self, color_code, content):\n        # O dict COLORS_MAP mapeia os c\u00f3digos de cores aos c\u00f3digos ANSI.\n        # Voc\u00ea pode adicionar mais cores ao dict, se desejar. As chaves s\u00e3o poss\u00edveis \n        # valores na c\u00e9lula e os valores s\u00e3o os c\u00f3digos ANSI correspondentes.\n        # Desta forma, verde ser\u00e1 usado para c\u00e9lulas vazias, ciano para c\u00e9lulas com 1 mina adjacente, etc.\n        color_code = str(color_code)\n        COLORS_MAP = {\n            \"0\": colorama.Fore.GREEN,\n            \"1\": colorama.Fore.CYAN,\n            \"2\": colorama.Fore.BLUE,\n            \"3\": colorama.Fore.RED,\n            \"4\": colorama.Fore.RED,\n            \"5\": colorama.Fore.MAGENTA,\n            \"6\": colorama.Fore.MAGENTA,\n            self.__BOMB_INDICATOR: colorama.Fore.RED,\n            self.__UNKNOWN_CELL_INDICATOR: colorama.Fore.WHITE,\n            \"C\": colorama.Fore.WHITE # Usado para as colunas de coordenadas\n        }\n\n        return f\"{COLORS_MAP[color_code]}{content}{colorama.Fore.RESET}\"\n\n    def show_board(self, target_board: list):\n        \"\"\"\n        Mostra o tabuleiro na tela\n        \"\"\"\n        board_str = f\"{colorama.Back.BLACK}\" # Adiciona um fundo preto ao tabuleiro\n        # Calcula a largura da linha do tabuleiro. Adicionamos 1 ao n\u00famero de colunas para incluir as coordenadas,\n        # um ao n\u00famero de caracteres por c\u00e9lula para incluir a '|' entre as c\u00e9lulas e um ao final para incluir o \u00faltimo '|'\n        row_width = (self.ncols+1) * (self.DISPLAY_CELL_CHARS + 1) + 1\n\n        # Agora, vamos gerar um pequeno cabe\u00e7alho com as coordenadas das colunas\n        header = \"\"\n        header += f\" Campo Minado {self.nrows}x{self.ncols} \".center(row_width, \"-\") + \"\\n\"\n        header += \"-\" * row_width + \"\\n\" # Adiciona uma linha horizontal para separar o cabe\u00e7alho do tabuleiro\n        header_col_indexer = [self.colorize(content=str(v).center(self.DISPLAY_CELL_CHARS), color_code=\"C\") for v in range(self.ncols)]\n        header += f\"|{'/'.center(self.DISPLAY_CELL_CHARS)}|\" + \"|\".join(c for c in header_col_indexer) + \"|\\n\" \n        header += \"-\"*row_width + \"\\n\"\n\n        # finalmente, vamos adicionar o cabe\u00e7alho ao tabuleiro\n        board_str += header\n\n        # Agora, vamos adicionar as linhas do tabuleiro\n        for ri in range(self.nrows):\n            start_index = self.ncols * ri\n            end_index = self.ncols * (ri + 1)         \n            cells = [self.colorize(content=str(v).center(self.DISPLAY_CELL_CHARS), color_code=v) for v in target_board[start_index:end_index]]\n            # Vamos adicioar, de uma vez s\u00f3, a linha e sua respectiva coordenada na coluna\n            board_str += f\"|{self.colorize('C', str(ri).center(self.DISPLAY_CELL_CHARS))}|\" + \"|\".join(c for c in cells) + \"|\\n\"\n        board_str += f\"{colorama.Back.RESET}\"\n        print(board_str)\n\n    @property\n    def show(self):\n        return self.show_board(target_board=self.board)\n\n    @property\n    def show_answer(self):\n        self.show_board(target_board=self.__secret_board)\n\n    def coord_to_index(self, row, col):\n        \"\"\"\n        Converte as coordenadas (linha, coluna) em um \u00edndice da lista unidimensional\n        \"\"\"\n        return row * self.ncols + col\n\n    def index_to_coord(self, index):\n        \"\"\"\n        Converte um \u00edndice da lista unidimensional em coordenadas (linha, coluna)\n        \"\"\"\n        return divmod(index, self.ncols) \n\n    def get_valid_adjacent_cells(self, row, col):\n        \"\"\"\n        Retorna os \u00edndices das c\u00e9lulas v\u00e1lidas adjacentes \u00e0 c\u00e9lula (row, col)\n        \"\"\"\n        cindex = self.coord_to_index(row, col)\n\n        adjacent_indexes = [\n            cindex-self.nrows-1, cindex-self.nrows, cindex-self.nrows+1,\n            cindex-1,            -1000             ,cindex+1,\n            cindex+self.nrows-1, cindex+self.nrows, cindex+self.nrows+1\n        ] \n\n        # a constante -1000 \u00e9 um valor simbolico para que os indices fiquem coerentes.\n        # Agora, deveremos remover os indices de celulas vizinhas seguindo o seguinte criterio:\n        # 1. Se o index for negativo (significa que nao existe linha 'acima', ou eh a constante simbolica)\n        # 2. Se o index for maior q o tabuleiro(neste caso, nao existe linha 'abaixo')\n        # 3. Se cindex % ncol = 1, deveremos remover os indices(do adjacent_indexes) 2, 5, e 8\n        # 4. se cindex % ncol = ncol, deveremos remover os indices(do adjacent_indexes) 0, 3 e 6\n        # obs: os passos 3 e 4 usam cindex(o valor de input). Ambos referem-se ao caso onde\n        # o indice de target est\u00e1 ou na coluna final, ou na coluna inicial. Logo nao existe \"esquerda\" ou \"direita\"\n\n        # Como os passos  3. e 4. removem valores do vetor de indice usando seus indices, vamos come\u00e7ar por eles \n        to_remove = []\n        if cindex % self.ncols == self.ncols - 1:\n            to_remove.extend([2, 5, 8])\n        elif cindex % self.ncols == 0:\n            to_remove.extend([0, 3, 6])\n\n        # Agora, vamos remover os indices que nao existem\n        # board_ index = indice da celula no tabuleiro; adj_index = indice no vetor de adjacent_indexes\n        adjacent_cells = [board_index for adj_index, board_index in enumerate(adjacent_indexes) if board_index &gt;= 0 and board_index &lt; self.nrows*self.ncols and adj_index not in to_remove]\n        return adjacent_cells\n\n    def count_adjacent_bombs(self, row, col):\n        \"\"\"\n        Conta o n\u00famero de bombas adjacentes \u00e0 c\u00e9lula (row, col)\n        \"\"\"\n        cindex = self.coord_to_index(row, col)\n\n        adjacent_cells = self.get_valid_adjacent_cells(row, col)\n        return sum(1 for adj_index in adjacent_cells if self.__secret_board[adj_index] == self.__BOMB_INDICATOR)\n\n    def recursive_count_adjacent_bombs(self, row, col):\n        \"\"\"\n        Conta o n\u00famero de bombas adjacentes \u00e0 c\u00e9lula (row, col) e \u00e0s c\u00e9lulas adjacentes a ela, de forma recursiva\n        \"\"\"\n        bombs_count = self.count_adjacent_bombs(row, col)\n        cindex = self.coord_to_index(row, col)\n        self.board[cindex] = bombs_count\n        if bombs_count &gt; 0:\n            return\n\n        adjacent_cells = self.get_valid_adjacent_cells(row, col)\n        for adj_index in adjacent_cells:\n            adj_row, adj_col = self.index_to_coord(adj_index)\n            if self.board[adj_index] == self.__UNKNOWN_CELL_INDICATOR:\n                self.recursive_count_adjacent_bombs(adj_row, adj_col)\n        return\n\n    def reveal(self, row, col):\n        \"\"\"\n        Revela a c\u00e9lula (row, col) e as c\u00e9lulas adjacentes a ela\n        \"\"\"\n        cindex = self.coord_to_index(row, col)\n        if self.__secret_board[cindex] == self.__BOMB_INDICATOR:\n            raise GameOverError(\"Voc\u00ea clicou em uma bomba! Game Over!\")\n            return\n        self.recursive_count_adjacent_bombs(row, col)\n\n    def play(self):\n        \"\"\"\n        Permite ao jogador interagir com o jogo\n        \"\"\"\n        while True:\n            self.show\n            row = int(input(\"Digite a linha da c\u00e9lula a ser revelada: \"))\n            col = int(input(\"Digite a coluna da c\u00e9lula a ser revelada: \"))\n            try:\n                os.system(\"cls\" if os.name == \"nt\" else \"clear\")\n                self.reveal(row, col)\n            except GameOverError as e:\n                print(e)\n                self.show_answer\n                self.show\n                break\n            if self.board.count(self.__UNKNOWN_CELL_INDICATOR) == self.nbombs:\n                print(\"Parab\u00e9ns! Voc\u00ea revelou todas as c\u00e9lulas vazias!\")\n                self.show_answer\n                self.show\n                break\n</code></pre>"},{"location":"matematica-estatistica/resolvendo-o-campo-minado-com-python/#parte-2-usando-sistemas-de-equacoes-lineares-para-resolver-o-campo-minado","title":"Parte 2 - Usando sistemas de equa\u00e7\u00f5es lineares para resolver o Campo Minado","text":"<p>TODO: Escrever a parte 2</p>"}]}